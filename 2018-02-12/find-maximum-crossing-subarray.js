
/**
 * This is the crossing subarray function (a.k.a the "conquer" step
 * of the divide and conquer algorithm). Starting at a given mid,
 * it starts there and works down to low finding the max subarray on
 * the left side. Then it works towards high finding the max subarray
 * on the right side. Taking those two indices, it returns that
 * result.
 * @param {Array<number>} deltas The deltas array generated by the transform function.
 * @param {number} low The current low index we're analyzing
 * @param {number} mid The midpoint of the array
 * @param {number} high The current high index we're analyzing
 */
const findMaxCrossingSubarray = (deltas, low, mid, high) => {
  let leftSum = -Infinity;
  let rightSum = -Infinity;
  let maxLeftIndex;
  let maxRightIndex;

  let sum = 0;

  // Starting at the mid point, find the largest subarray on the left side
  for (let i = mid; i >= low; i--) {
    sum += deltas[i];
    if (sum > leftSum) {
      leftSum = sum;
      maxLeftIndex = i;
    }
  }

  sum = 0;

  // Starting at the mid point, find the largest subarray on the right side
  for (let i = mid + 1; i <= high; i++) {
    sum += deltas[i];
    if (sum > rightSum) {
      rightSum = sum;
      maxRightIndex = i;
    }
  }

  // Return those results
  return {
    buy: maxLeftIndex,
    sell: maxRightIndex + 1,
    profit: leftSum + rightSum,
  };
};

module.exports = {findMaxCrossingSubarray};
